module ShikiHighlighter

using Documenter

export shiki_html, add_shiki_assets

"""
    shiki_html(; theme="github-light", dark_theme="github-dark", languages=[...], kwargs...)

Returns Documenter.HTML() with Shiki highlighting features.
Supports all Documenter.HTML() options.

# Shiki-specific options
- `theme::String="github-light"`: Default theme
- `dark_theme::String="github-dark"`: Dark mode theme
- `languages::Vector{String}`: List of supported languages
- `cdn_url::String="https://esm.sh"`: Shiki library CDN URL
- `load_themes::Vector{String}=String[]`: List of themes to load

# Documenter.HTML options
All other keyword arguments are passed to Documenter.HTML().
"""
function shiki_html(;
    # Shiki-specific options
    theme="{{{SHIKI_THEME}}}",
    dark_theme="{{{SHIKI_DARK_THEME}}}",
    languages={{{SHIKI_LANGUAGES}}},
    cdn_url="{{{SHIKI_CDN_URL}}}",
    load_themes=String[],
    # Documenter.HTML basic options
    prettyurls=true,
    disable_git=false,
    edit_link=nothing,
    canonical=nothing,
    assets=String[],
    analytics="",
    collapselevel=2,
    sidebar_sitename=true,
    mathengine=Documenter.KaTeX(),
    footer=nothing,
    ansicolor=false,
    warn_outdated=true,
    prerender=true,  # Skip loading highlight.js
    highlights=String[],  # No additional languages
    kwargs... # Other Documenter.HTML options
)
    # Use theme and dark_theme if load_themes is empty
    if isempty(load_themes)
        load_themes = unique([theme, dark_theme])
    end

    # Add Shiki assets (loaded from root directory)
    shiki_assets = copy(assets)
    push!(shiki_assets, "shiki-plugin.css")
    push!(shiki_assets, "shiki-plugin.js")

    # Save Shiki configuration globally (used for asset generation)
    global SHIKI_CONFIG = (
        theme=theme,
        dark_theme=dark_theme,
        languages=languages,
        cdn_url=cdn_url,
        load_themes=load_themes
    )

    # Return standard Documenter.HTML()
    return Documenter.HTML(;
        prettyurls=prettyurls,
        disable_git=disable_git,
        edit_link=edit_link,
        canonical=canonical,
        assets=shiki_assets,
        analytics=analytics,
        collapselevel=collapselevel,
        sidebar_sitename=sidebar_sitename,
        mathengine=mathengine,
        footer=footer,
        ansicolor=ansicolor,
        warn_outdated=warn_outdated,
        prerender=prerender,
        highlights=highlights,
        kwargs...
    )
end

# Global configuration variable
SHIKI_CONFIG = nothing

"""
    add_shiki_assets(build_dir::String)

Adds Shiki CSS and JavaScript assets to the specified build directory.
Call this after makedocs().

# Example
```julia
makedocs(
    sitename="My Documentation",
    format=shiki_html(theme="github-dark"),
    pages=["Home" => "index.md"]
)
add_shiki_assets("docs/build")  # Add assets after build
```
"""
function add_shiki_assets(build_dir::String)
    if SHIKI_CONFIG === nothing
        @warn "Shiki configuration not found. Please use shiki_html() function first."
        return
    end

    # Create files in build directory root (expected by Documenter)
    mkpath(build_dir)

    # Create CSS file
    css_content = generate_shiki_css()
    css_path = joinpath(build_dir, "shiki-plugin.css")
    write(css_path, css_content)

    # Create JavaScript file
    js_content = generate_shiki_javascript(SHIKI_CONFIG)
    js_path = joinpath(build_dir, "shiki-plugin.js")
    write(js_path, js_content)

    @info "üì¶ Created Shiki assets: $(css_path), $(js_path)"
end

"""
    generate_shiki_css()

Generates CSS styles for Shiki.
"""
function generate_shiki_css()
    return """
/* Shiki Highlighter Plugin Styles */

/* Default code block style (before Shiki application) */
pre code {
    color: inherit !important;
    background: transparent !important;
}

html.theme--dark pre code,
html.theme--documenter-dark pre code {
    color: #c9d1d9 !important;
}

.shiki-loading {
    position: relative;
    background: #f6f8fa;
    border-radius: 6px;
    padding: 16px;
    font-family: 'JetBrains Mono', 'Fira Code', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.5;
    border: 1px solid #e1e4e8;
    margin: 1em 0;
}

.shiki-loading::after {
    content: "‚ö° Loading syntax highlighting...";
    color: #666;
    font-style: italic;
    opacity: 0.7;
    animation: pulse 1.5s ease-in-out infinite alternate;
}

@keyframes pulse {
    from { opacity: 0.4; }
    to { opacity: 0.8; }
}

pre.shiki {
    background-color: transparent !important;
    border-radius: 6px;
    padding: 0.5rem 0.75rem !important;
    overflow-x: clip;
    overflow-y: visible;
    font-family: 'JetBrains Mono', 'Fira Code', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.5;
    border: 1px solid #e1e4e8;
    margin: 1em 0;
    position: relative;
}

.shiki code {
    background: none !important;
    padding: 0 !important;
    border-radius: 0 !important;
    font-weight: inherit;
    color: inherit;
    font-size: inherit;
}

.shiki pre {
    margin: 0;
    padding: 0;
    background: transparent;
    overflow: visible;
    font-size: inherit;
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    .shiki-loading {
        background: #0d1117;
        border-color: #30363d;
        color: #c9d1d9;
    }

    .shiki {
        border-color: #30363d;
    }
}

/* Integration with Documenter themes */
html.theme--dark .shiki-loading,
html.theme--documenter-dark .shiki-loading {
    background: #0d1117;
    border-color: #30363d;
    color: #c9d1d9;
}

html.theme--dark .shiki,
html.theme--documenter-dark .shiki {
    border-color: #30363d;
}

/* Use colors provided by Shiki theme - keywords and numbers as-is */
/* Override only variable names (normal identifiers like i, j) */

/* Light theme: make variable names black */
html.theme--light .shiki span[style*="color:#383A42"],
html.theme--light .shiki span[style*="color:#383a42"] {
    color: #000000 !important;
}

/* Dark theme: make variable names white */
html.theme--dark .shiki span[style*="color:#383A42"],
html.theme--dark .shiki span[style*="color:#383a42"],
html.theme--documenter-dark .shiki span[style*="color:#383A42"],
html.theme--documenter-dark .shiki span[style*="color:#383a42"] {
    color: #ffffff !important;
}

/* Darken light text in light theme */
html.theme--light .shiki span[style*="color:#6F42C1"],
html.theme--light .shiki span[style*="color:#6f42c1"] {
    color: #5a32a3 !important;  /* darker purple */
}

html.theme--light .shiki span[style*="color:#032F62"],
html.theme--light .shiki span[style*="color:#032f62"] {
    color: #022543 !important;  /* darker blue */
}

/* Darken comments in light theme */
html.theme--light .shiki span[style*="color:#A0A1A7"],
html.theme--light .shiki span[style*="color:#a0a1a7"],
html.theme--light .shiki span[style*="color:#969896"],
html.theme--light .shiki span[style*="color:#8E908C"] {
    color: #5a5d62 !important;  /* darker gray */
}

/* Darken light gray text in light theme */
html.theme--light .shiki span[style*="color:#383A42"],
html.theme--light .shiki span[style*="color:#383a42"] {
    color: #000000 !important;  /* pure black */
}

/* Make identifiers (gray text) as dark as comments in light theme */
html.theme--light .shiki span[style*="color:#959DA5"],
html.theme--light .shiki span[style*="color:#959da5"],
html.theme--light .shiki span[style*="color:#6A737D"],
html.theme--light .shiki span[style*="color:#6a737d"] {
    color: #5a5d62 !important;  /* same dark gray as comments */
}

/* Darken default color identifiers in light theme */
html.theme--light .shiki span[style*="color:#24292E"],
html.theme--light .shiki span[style*="color:#24292e"] {
    color: #000000 !important;  /* pure black */
}

/* Darken variable and function names in light theme */
html.theme--light .shiki span[style*="color:#E45649"],
html.theme--light .shiki span[style*="color:#e45649"] {
    color: #d73a49 !important;  /* darker red */
}

html.theme--light .shiki span[style*="color:#4078F2"],
html.theme--light .shiki span[style*="color:#4078f2"] {
    color: #0366d6 !important;  /* darker blue */
}

/* Darken light pink in light theme */
html.theme--light .shiki span[style*="color:#F97583"],
html.theme--light .shiki span[style*="color:#f97583"] {
    color: #000000 !important;  /* pure black (identifier) */
}

/* Darken light blue in light theme */
html.theme--light .shiki span[style*="color:#79B8FF"],
html.theme--light .shiki span[style*="color:#79b8ff"],
html.theme--light .shiki span[style*="color:#79B8ff"] {
    color: #000000 !important;  /* pure black (identifier) */
}

/* Darken light gray in light theme */
html.theme--light .shiki span[style*="color:#E1E4E8"],
html.theme--light .shiki span[style*="color:#e1e4e8"],
html.theme--light .shiki span[style*="color:#E1E4e8"] {
    color: #000000 !important;  /* pure black */
}

/* Darken light green in light theme */
html.theme--light .shiki span[style*="color:#85E89D"],
html.theme--light .shiki span[style*="color:#85e89d"] {
    color: #22863a !important;  /* dark green */
}

/* Darken light purple in light theme (one-light theme) */
html.theme--light .shiki span[style*="color:#B392F0"],
html.theme--light .shiki span[style*="color:#b392f0"] {
    color: #6f42c1 !important;  /* dark purple */
}

/* Line number support */
.shiki .line {
    min-height: 1.5em;
}

/* Scrollbar styling */
.shiki::-webkit-scrollbar {
    height: 8px;
}

.shiki::-webkit-scrollbar-track {
    background: transparent;
}

.shiki::-webkit-scrollbar-thumb {
    background: rgba(0,0,0,0.2);
    border-radius: 4px;
}

.shiki::-webkit-scrollbar-thumb:hover {
    background: rgba(0,0,0,0.3);
}

/* Copy button */
.shiki .copy-button {
    position: absolute;
    top: 8px;
    right: 8px;
    opacity: 0;
    transition: opacity 0.2s;
    background: rgba(255,255,255,0.9);
    border: 1px solid #e1e4e8;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    font-family: inherit;
    z-index: 10;
}

.shiki:hover .copy-button {
    opacity: 1;
}

.shiki .copy-button:hover {
    background: rgba(255,255,255,1);
}

html.theme--dark .shiki .copy-button ,
html.theme--documenter-dark .shiki .copy-button {
    background: rgba(13,17,23,0.9);
    border-color: #30363d;
    color: #c9d1d9;
}

html.theme--dark .shiki .copy-button:hover ,
html.theme--documenter-dark .shiki .copy-button:hover {
    background: rgba(13,17,23,1);
}

/* Highlighted line style - Level 1 (yellow) */
.shiki .highlighted,
.shiki .line.highlighted,
.shiki .highlight-level-1 {
    background-color: rgba(255, 255, 0, 0.1);
    display: inline-block;
    position: relative;
}

.shiki .highlighted::before,
.shiki .line.highlighted::before,
.shiki .highlight-level-1::before {
    content: '';
    position: absolute;
    left: -16px;
    right: -16px;
    top: 0;
    bottom: 0;
    background-color: rgba(255, 255, 0, 0.1);
    z-index: -1;
}

/* Level 2 (red) */
.shiki .highlight-level-2 {
    background-color: rgba(255, 100, 100, 0.15);
    display: inline-block;
    position: relative;
}

/* Apply normal text color rules even for highlighted lines */

.shiki .highlight-level-2::before {
    content: '';
    position: absolute;
    left: -16px;
    right: -16px;
    top: 0;
    bottom: 0;
    background-color: rgba(255, 100, 100, 0.15);
    z-index: -1;
}

/* Level 3 (green) */
.shiki .highlight-level-3 {
    background-color: rgba(100, 255, 100, 0.15);
    display: inline-block;
    position: relative;
}

.shiki .highlight-level-3::before {
    content: '';
    position: absolute;
    left: -16px;
    right: -16px;
    top: 0;
    bottom: 0;
    background-color: rgba(100, 255, 100, 0.15);
    z-index: -1;
}

/* Level 4 (blue) */
.shiki .highlight-level-4 {
    background-color: rgba(100, 150, 255, 0.15);
    display: inline-block;
    position: relative;
}

.shiki .highlight-level-4::before {
    content: '';
    position: absolute;
    left: -16px;
    right: -16px;
    top: 0;
    bottom: 0;
    background-color: rgba(100, 150, 255, 0.15);
    z-index: -1;
}

/* Highlight in dark mode - change background color of entire line */
html.theme--dark .shiki .highlighted,
html.theme--dark .shiki .line.highlighted,
html.theme--dark .shiki .highlight-level-1 ,
html.theme--documenter-dark .shiki .highlight-level-1 {
    /* Level 1: Yellow-ish - light background for entire line */
    background-color: rgba(255, 234, 0, 0.1);
    display: inline-block;
    position: relative;
}

html.theme--dark .shiki .highlighted::before,
html.theme--dark .shiki .line.highlighted::before,
html.theme--dark .shiki .highlight-level-1::before ,
html.theme--documenter-dark .shiki .highlight-level-1::before {
    content: '';
    position: absolute;
    left: -16px;
    right: -16px;
    top: 0;
    bottom: 0;
    background-color: rgba(255, 234, 0, 0.1);
    z-index: -1;
}

/* Use normal color rules for highlighted lines (no filter) */

html.theme--dark .shiki .highlight-level-2 ,
html.theme--documenter-dark .shiki .highlight-level-2 {
    /* Level 2: Red-ish - light background for entire line */
    background-color: rgba(255, 95, 109, 0.1);
    display: inline-block;
    position: relative;
}

html.theme--dark .shiki .highlight-level-2::before ,
html.theme--documenter-dark .shiki .highlight-level-2::before {
    content: '';
    position: absolute;
    left: -16px;
    right: -16px;
    top: 0;
    bottom: 0;
    background-color: rgba(255, 95, 109, 0.1);
    z-index: -1;
}


html.theme--dark .shiki .highlight-level-3 ,
html.theme--documenter-dark .shiki .highlight-level-3 {
    /* Level 3: Green-ish - light background for entire line */
    background-color: rgba(95, 255, 135, 0.1);
    display: inline-block;
    position: relative;
}

html.theme--dark .shiki .highlight-level-3::before ,
html.theme--documenter-dark .shiki .highlight-level-3::before {
    content: '';
    position: absolute;
    left: -16px;
    right: -16px;
    top: 0;
    bottom: 0;
    background-color: rgba(95, 255, 135, 0.1);
    z-index: -1;
}


html.theme--dark .shiki .highlight-level-4 ,
html.theme--documenter-dark .shiki .highlight-level-4 {
    /* Level 4: Blue-ish - light background for entire line */
    background-color: rgba(100, 181, 255, 0.1);
    display: inline-block;
    position: relative;
}

html.theme--dark .shiki .highlight-level-4::before ,
html.theme--documenter-dark .shiki .highlight-level-4::before {
    content: '';
    position: absolute;
    left: -16px;
    right: -16px;
    top: 0;
    bottom: 0;
    background-color: rgba(100, 181, 255, 0.1);
    z-index: -1;
}


/* Diff display style (optional) */
.shiki .diff.add {
    background-color: rgba(46, 160, 67, 0.15);
}

.shiki .diff.remove {
    background-color: rgba(248, 81, 73, 0.15);
}

html.theme--dark .shiki .diff.add ,
html.theme--documenter-dark .shiki .diff.add {
    background-color: rgba(46, 160, 67, 0.2);
}

html.theme--dark .shiki .diff.remove ,
html.theme--documenter-dark .shiki .diff.remove {
    background-color: rgba(248, 81, 73, 0.2);
}

/* Hide Catppuccin theme from settings menu */
#documenter-themepicker option[value="catppuccin-latte"],
#documenter-themepicker option[value="catppuccin-frappe"],
#documenter-themepicker option[value="catppuccin-macchiato"],
#documenter-themepicker option[value="catppuccin-mocha"] {
    display: none;
}
"""
end

"""
    generate_shiki_javascript(config)

Generates JavaScript code for Shiki.
"""
function generate_shiki_javascript(config)
    themes_json = join(["\"$theme\"" for theme in config.load_themes], ", ")
    languages_json = join(["\"$lang\"" for lang in config.languages], ", ")

    return """
// Shiki Highlighter for Documenter.jl
(function() {
    'use strict';

    const SHIKI_CONFIG = {
        theme: '$(config.theme)',
        darkTheme: '$(config.dark_theme)',
        languages: [$(languages_json)],
        themes: [$(themes_json)],
        cdnUrl: '$(config.cdn_url)'
    };

    let shikiHighlighter = null;
    let isLoading = false;
    let loadingPromise = null;

    console.log('üé® ShikiHighlighter initialized');
    console.log('üìã Config:', SHIKI_CONFIG);

    // Variable to store Transformers
    let shikiTransformers = null;

    // Dynamic import of Shiki
    async function loadShiki() {
        if (shikiHighlighter) return shikiHighlighter;
        if (isLoading) return loadingPromise;

        isLoading = true;

        loadingPromise = (async () => {
            try {
                console.log('üì¶ Loading Shiki highlighter and transformers...');

                // Load Shiki and Transformers in ES Modules format
                const shiki = await import(`\${SHIKI_CONFIG.cdnUrl}/shiki@1.22.2`);
                const transformersModule = await import(`\${SHIKI_CONFIG.cdnUrl}/@shikijs/transformers@1.22.2`);

                // Save Transformers
                shikiTransformers = transformersModule;

                shikiHighlighter = await shiki.createHighlighter({
                    themes: SHIKI_CONFIG.themes,
                    langs: SHIKI_CONFIG.languages
                });

                console.log('‚úÖ Shiki highlighter and transformers loaded successfully');
                return shikiHighlighter;

            } catch (error) {
                console.error('‚ùå Failed to load Shiki:', error);
                return null;
            } finally {
                isLoading = false;
            }
        })();

        return loadingPromise;
    }

    // Theme detection
    function getCurrentTheme() {
        // Check Documenter theme
        const htmlElement = document.documentElement;

        // Check multiple dark theme classes
        const isDark = htmlElement.classList.contains('theme--dark') ||
                      htmlElement.classList.contains('theme--documenter-dark') ||
                      htmlElement.classList.contains('documenter-dark') ||
                      htmlElement.getAttribute('data-theme') === 'dark' ||
                      htmlElement.getAttribute('data-theme') === 'documenter-dark';

        console.log(`üåì Theme detection: isDark=\${isDark}, classes=\${htmlElement.className}`);

        // Use dark theme if dark theme is selected
        const selectedTheme = isDark ? SHIKI_CONFIG.darkTheme : SHIKI_CONFIG.theme;

        console.log(`üé® Using theme: \${selectedTheme} (isDark=\${isDark})`);

        return selectedTheme;
    }

    // Parse range string: "1,3-4" -> [1, 3, 4]
    function parseHighlightRanges(rangeStr) {
        const ranges = [];
        rangeStr.split(',').forEach(part => {
            part = part.trim();
            if (part.includes('-')) {
                const [start, end] = part.split('-').map(s => parseInt(s.trim()));
                for (let i = start; i <= end; i++) {
                    ranges.push(i);
                }
            } else {
                const num = parseInt(part);
                if (!isNaN(num)) {
                    ranges.push(num);
                }
            }
        });
        return ranges;
    }

    // Add highlight class to specific lines (level-aware)
    function addHighlightToLines(preElement, lineHighlights) {
        const codeElement = preElement.querySelector('code');
        if (!codeElement) return;

        // Get each line <span> generated by Shiki
        const lines = codeElement.querySelectorAll('.line');

        // If lineHighlights is an array (backward compatibility)
        if (Array.isArray(lineHighlights)) {
            lineHighlights.forEach(lineNum => {
                const lineIndex = lineNum - 1;
                if (lines[lineIndex]) {
                    lines[lineIndex].classList.add('highlighted');
                }
            });
        }
        // If lineHighlights is an object (with level, bgcolor support)
        else if (typeof lineHighlights === 'object') {
            Object.entries(lineHighlights).forEach(([lineNum, info]) => {
                const lineIndex = parseInt(lineNum) - 1;
                if (lines[lineIndex]) {
                    // If info is a number (backward compatibility)
                    if (typeof info === 'number') {
                        const colorLevel = ((info - 1) % 4) + 1;
                        lines[lineIndex].classList.add(`highlight-level-\${colorLevel}`);
                    }
                    // If info is an object (level + bgcolor)
                    else if (typeof info === 'object') {
                        const level = info.level;
                        const bgcolor = info.bgcolor;

                        if (bgcolor) {
                            // Specify custom background color
                            lines[lineIndex].style.backgroundColor = bgcolor;
                            lines[lineIndex].style.display = 'inline-block';
                            lines[lineIndex].style.width = '100%';
                            lines[lineIndex].style.position = 'relative';
                            console.log(`   üé® Applied custom bgcolor "\${bgcolor}" to line \${lineNum}`);
                        } else {
                            // Use default level color
                            const colorLevel = ((level - 1) % 4) + 1;
                            lines[lineIndex].classList.add(`highlight-level-\${colorLevel}`);
                        }
                    }
                }
            });
        }
    }

    // Highlight code block
    async function highlightCodeBlock(codeBlock) {
        const pre = codeBlock.parentElement;

        // Save original code (use from data attribute if saved)
        let code = pre.dataset.originalCode || codeBlock.textContent;

        // Save original code and language on first render
        if (!pre.dataset.originalCode) {
            pre.dataset.originalCode = code;
            const langClass = Array.from(codeBlock.classList).find(cls => cls.startsWith('language-'));
            if (langClass) {
                pre.dataset.originalLang = langClass;
            }
        }

        const langClass = Array.from(codeBlock.classList).find(cls => cls.startsWith('language-'));
        let lang = langClass ? langClass.replace('language-', '') : 'text';

        // Skip Shiki processing for languages starting with nohighlight-
        if (lang.startsWith('nohighlight-') || lang === 'nohighlight') {
            console.log(`üö´ Skipping Shiki for nohighlight block`);
            return;
        }

        // Treat julia-repl as julia
        if (lang === 'julia-repl') {
            lang = 'julia';
        }

        // Detect @highlight: format
        let customHighlightLines = {};
        const lines = code.split('\\n');
        let filteredLines = [];
        let highlightStack = []; // Nesting level stack
        let lineOffset = 0;

        // Process each line
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            // @highlight: 1,3-4 format
            if (i === 0 && line.match(/^\\s*[#\\/\\/]\\s*@highlight:\\s*([\\d,-]+)/)) {
                const match = line.match(/^\\s*[#\\/\\/]\\s*@highlight:\\s*([\\d,-]+)/);
                const ranges = parseHighlightRanges(match[1]);
                ranges.forEach(lineNum => {
                    customHighlightLines[lineNum] = 1;
                });
                console.log(`üìå Custom highlight detected: lines \$\${ranges.join(', ')}`);
                lineOffset++;
                continue; // Skip this line
            }

            // Process inline @highlight-end first
            if (line.match(/[#\\/\\/]\\s*@highlight-end\\s*\$/)) {
                // Apply current highlight level (before processing @highlight-end)
                if (highlightStack.length > 0) {
                    const current = highlightStack[highlightStack.length - 1];
                    customHighlightLines[i - lineOffset + 1] = current;
                    console.log(`   üìç Line \$\${i - lineOffset + 1} will be highlighted with level \$\${current.level} (before end)`);
                }
                console.log(`üîö Found @highlight-end at line \$\${i + 1}`);
                highlightStack.pop();
                // Remove directive and keep line
                const cleanedLine = line.replace(/\\s*[#\\/\\/]\\s*@highlight-end\\s*\$/, '');
                filteredLines.push(cleanedLine);
                continue;
            }

            // Process standalone @highlight-auto-end (at line start) first
            if (line.match(/^\\s*[#\\/\\/]\\s*@highlight-auto-end\\s*\$/)) {
                console.log(`üîö Found @highlight-auto-end (standalone) at line \$\${i + 1} - will be removed`);
                highlightStack.pop();
                lineOffset++;
                continue; // Skip this line (remove)
            }

            // Inline @highlight-auto-end
            if (line.match(/[#\\/\\/]\\s*@highlight-auto-end\\s*\$/)) {
                // Apply current highlight level (before processing @highlight-auto-end)
                if (highlightStack.length > 0) {
                    const current = highlightStack[highlightStack.length - 1];
                    customHighlightLines[i - lineOffset + 1] = current;
                    console.log(`   üìç Line \$\${i - lineOffset + 1} will be highlighted with level \$\${current.level} (before auto-end)`);
                }
                console.log(`üîö Found @highlight-auto-end at line \$\${i + 1}`);
                highlightStack.pop();
                // Remove directive and keep line
                const cleanedLine = line.replace(/\\s*[#\\/\\/]\\s*@highlight-auto-end\\s*\$/, '');
                filteredLines.push(cleanedLine);
                continue;
            }

            // @highlight-start[level] format (at line start or end)
            const startMatch = line.match(/^\\s*[#\\/\\/]\\s*@highlight-start(?:\\[(\\d+)\\])?|[#\\/\\/]\\s*@highlight-start(?:\\[(\\d+)\\])?\\s*\$/);
            if (startMatch) {
                const level = startMatch[1] || startMatch[2] || 1;
                const levelNum = typeof level === 'string' ? parseInt(level) : 1;

                // Validate level
                if (levelNum < 1) {
                    console.error(`‚ùå ERROR at line \$\${i + 1}: @highlight-start level must be >= 1, got \$\${levelNum}`);
                    filteredLines.push(line);
                    continue;
                }

                // Validate nesting continuity
                const expectedLevel = highlightStack.length + 1;
                if (levelNum !== expectedLevel) {
                    // First level must be 1
                    if (highlightStack.length === 0) {
                        console.error(`‚ùå ERROR at line \$\${i + 1}: First @highlight-start must be level 1, got \$\${levelNum}`);
                    } else {
                        console.error(`‚ùå ERROR at line \$\${i + 1}: @highlight-start[\$\${levelNum}] skips nesting levels. Expected level \$\${expectedLevel} (current stack: [\$\${highlightStack.join(', ')}])`);
                    }
                    // Continue processing even on error, but warn
                }

                console.log(`üî• Found @highlight-start[\$\${levelNum}] at line \$\${i + 1}`);
                highlightStack.push({ level: levelNum, bgcolor: null });
                // Skip entire line if @highlight-start is at line start
                if (line.match(/^\\s*[#\\/\\/]\\s*@highlight-start/)) {
                    lineOffset++;
                    continue;
                }
                // Remove directive and keep line if @highlight-start is at line end
                const cleanedLine = line.replace(/\\s*[#\\/\\/]\\s*@highlight-start(?:\\[(\\d+)\\])?\\s*\$/, '');
                filteredLines.push(cleanedLine);
                continue;
            }

            // @highlight-auto-start format (auto-nesting, optional bgcolor)
            const autoStartMatch = line.match(/^\\s*[#\\/\\/]\\s*@highlight-auto-start(?:,\\s*bgcolor=([#\\w]+))?|[#\\/\\/]\\s*@highlight-auto-start(?:,\\s*bgcolor=([#\\w]+))?\\s*\$/);
            if (autoStartMatch) {
                // Automatically determine level from stack size (level number increases, colors cycle 1-4)
                const autoLevel = highlightStack.length + 1;
                const bgcolor = autoStartMatch[1] || autoStartMatch[2] || null;

                if (bgcolor) {
                    console.log(`üî• Found @highlight-auto-start,bgcolor=\$\${bgcolor} at line \$\${i + 1}, auto level: \$\${autoLevel}`);
                } else {
                    console.log(`üî• Found @highlight-auto-start at line \$\${i + 1}, auto level: \$\${autoLevel}`);
                }

                // Save level and background color as object
                highlightStack.push({ level: autoLevel, bgcolor: bgcolor });

                // Skip entire line if at line start
                if (line.match(/^\\s*[#\\/\\/]\\s*@highlight-auto-start/)) {
                    lineOffset++;
                    continue;
                }
                // Remove directive and keep line if at line end
                const cleanedLine = line.replace(/\\s*[#\\/\\/]\\s*@highlight-auto-start(?:,\\s*bgcolor=[#\\w]+)?\\s*\$/, '');
                filteredLines.push(cleanedLine);
                continue;
            }

            // Standalone @highlight-end at line start (remove - not highlighted)
            if (line.match(/^\\s*[#\\/\\/]\\s*@highlight-end\\s*\$/)) {
                console.log(`üîö Found @highlight-end (standalone) at line \$\${i + 1} - will be removed`);
                highlightStack.pop();
                lineOffset++;
                continue; // Skip this line (remove)
            }

            // Apply current highlight level
            if (highlightStack.length > 0) {
                // Use deepest level (last element)
                const current = highlightStack[highlightStack.length - 1];
                customHighlightLines[i - lineOffset + 1] = current;
                console.log(`   üìç Line \$\${i - lineOffset + 1} will be highlighted with level \$\${current.level}`);
            }

            filteredLines.push(line);
        }

        // Use filtered code
        code = filteredLines.join('\\n');

        // Debug: log filteredLines content
        if (Object.keys(customHighlightLines).length > 0) {
            console.log('DEBUG: filteredLines (' + filteredLines.length + ' lines):', filteredLines);
            console.log('DEBUG: code after join:', code);
        }

        // Skip Shiki processing for text language (plain text display)
        if (lang === 'text') {
            console.log(`üìù Skipping Shiki for plain text block`);
            return;
        }

        // Skip if language is not supported
        if (!SHIKI_CONFIG.languages.includes(lang)) {
            console.log(`‚ö†Ô∏è  Skipping unsupported language: \${lang}`);
            return;
        }

        try {
            const highlighter = await loadShiki();
            if (!highlighter) {
                console.warn('‚ö†Ô∏è  Highlighter not available, skipping...');
                return;
            }

            const theme = getCurrentTheme();
            console.log(`üé® Highlighting \${lang} code with theme: \${theme}`);

            // Use Transformers to highlight
            const transformers = [];
            if (shikiTransformers) {
                // Highlight by metadata {1,3-4} format
                if (shikiTransformers.transformerMetaHighlight) {
                    transformers.push(shikiTransformers.transformerMetaHighlight());
                }
                // Highlight by comment notation [!code highlight]
                if (shikiTransformers.transformerNotationHighlight) {
                    transformers.push(shikiTransformers.transformerNotationHighlight({
                        matchAlgorithm: 'v3'  // Count from line after comment line
                    }));
                }
                // Transformer for diff display (optional)
                if (shikiTransformers.transformerNotationDiff) {
                    transformers.push(shikiTransformers.transformerNotationDiff({
                        matchAlgorithm: 'v3'
                    }));
                }
            }

            const html = highlighter.codeToHtml(code, {
                lang,
                theme,
                transformers: transformers
            });

            // Create new Shiki element
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            const shikiPre = tempDiv.querySelector('pre');

            if (shikiPre) {
                // Apply if custom highlight lines exist
                if (Object.keys(customHighlightLines).length > 0) {
                    console.log(`‚ú® Applying highlights:`, customHighlightLines);
                    addHighlightToLines(shikiPre, customHighlightLines);
                }

                // Add copy button
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = 'Copy';
                copyButton.onclick = (e) => {
                    e.preventDefault();
                    navigator.clipboard.writeText(code).then(() => {
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => copyButton.textContent = 'Copy', 2000);
                    }).catch(() => {
                        // Fallback: use textarea
                        const textarea = document.createElement('textarea');
                        textarea.value = code;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => copyButton.textContent = 'Copy', 2000);
                    });
                };
                shikiPre.appendChild(copyButton);

                // Replace original element
                const parentPre = codeBlock.closest('pre');
                if (parentPre) {
                    parentPre.parentNode.replaceChild(shikiPre, parentPre);
                } else {
                    codeBlock.parentNode.replaceChild(shikiPre, codeBlock);
                }
            }

        } catch (error) {
            console.error('‚ùå Error highlighting code:', error);
        }
    }

    // Process all code blocks
    async function highlightAllCodeBlocks() {
        // Skip if already processing
        if (highlightAllCodeBlocks.isRunning) {
            console.log('‚è≥ Highlight already in progress, skipping...');
            return;
        }
        highlightAllCodeBlocks.isRunning = true;

        try {
            // Select all code blocks including those with highlight.js class
            // Process even with hljs class
            const codeBlocks = document.querySelectorAll('pre:not(.shiki) code[class*="language-"], pre:not(.shiki) code.hljs, pre:not(.shiki) code:not([class])');

            if (codeBlocks.length === 0) {
                console.log('üìÑ No unprocessed code blocks found');
                return;
            }

            console.log(`üîç Found \${codeBlocks.length} code blocks to highlight`);

            // Show loading state
            codeBlocks.forEach(block => {
                const pre = block.closest('pre');
                if (pre && !pre.classList.contains('shiki')) {
                    pre.classList.add('shiki-loading');
                }
            });

            // Limit concurrent executions with batch processing
            const BATCH_SIZE = 5;
            const codeBlocksArray = Array.from(codeBlocks);

            for (let i = 0; i < codeBlocksArray.length; i += BATCH_SIZE) {
                const batch = codeBlocksArray.slice(i, i + BATCH_SIZE);
                await Promise.all(batch.map(highlightCodeBlock));
            }

            // Remove loading state
            document.querySelectorAll('.shiki-loading').forEach(el => {
                el.classList.remove('shiki-loading');
            });

            console.log(`üéâ Successfully highlighted \${codeBlocks.length} code blocks with Shiki`);
        } finally {
            highlightAllCodeBlocks.isRunning = false;
        }
    }

    // Monitor theme changes
    function observeThemeChanges() {
        const observer = new MutationObserver(async (mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === 'attributes' &&
                    (mutation.attributeName === 'class' || mutation.attributeName === 'data-theme')) {
                    console.log('üé® Theme changed, re-highlighting...');

                    // Reset Highlighter instance
                    highlighterInstance = null;

                    // Restore existing Shiki blocks to original state
                    const blocks = document.querySelectorAll('pre.shiki');
                    for (const pre of blocks) {
                        const codeElement = pre.querySelector('code');
                        if (codeElement && pre.dataset.originalCode) {
                            // Restore original code
                            codeElement.textContent = pre.dataset.originalCode;
                            // Remove Shiki class to allow reprocessing
                            pre.classList.remove('shiki');
                            // Keep original class
                            const langClass = pre.dataset.originalLang;
                            if (langClass && !codeElement.classList.contains(langClass)) {
                                codeElement.classList.add(langClass);
                            }
                        }
                    }

                    // Wait a bit then re-highlight
                    await new Promise(resolve => setTimeout(resolve, 200));
                    await highlightAllCodeBlocks();
                    break;
                }
            }
        });

        observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class', 'data-theme']
        });

        // Also monitor prefers-color-scheme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', async () => {
            console.log('üåô System theme changed, re-highlighting...');

            // Reset Highlighter instance
            highlighterInstance = null;

            // Restore existing Shiki blocks to original state
            const blocks = document.querySelectorAll('pre.shiki');
            for (const pre of blocks) {
                const codeElement = pre.querySelector('code');
                if (codeElement && pre.dataset.originalCode) {
                    // Restore original code
                    codeElement.textContent = pre.dataset.originalCode;
                    // Remove Shiki class to allow reprocessing
                    pre.classList.remove('shiki');
                    // Keep original class
                    const langClass = pre.dataset.originalLang;
                    if (langClass && !codeElement.classList.contains(langClass)) {
                        codeElement.classList.add(langClass);
                    }
                }
            }

            // Wait a bit then re-highlight
            await new Promise(resolve => setTimeout(resolve, 200));
            await highlightAllCodeBlocks();
        });
    }

    // Execute when DOM is ready
    function initialize() {
        // Start monitoring theme changes first
        observeThemeChanges();

        // Try highlighting at multiple timings
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                highlightAllCodeBlocks();
            });
        } else {
            // Execute immediately
            highlightAllCodeBlocks();
        }

        // Wait for Documenter initialization to complete
        setTimeout(() => {
            highlightAllCodeBlocks();
        }, 250);

        // Delay further and re-execute (fallback)
        setTimeout(() => {
            highlightAllCodeBlocks();
        }, 1000);
    }

    // Execute initialization
    initialize();

    // Also execute after entire page load
    window.addEventListener('load', () => {
        setTimeout(highlightAllCodeBlocks, 100);
    });

    // Publish globally (for debugging)
    window.ShikiHighlighter = {
        rehighlight: highlightAllCodeBlocks,
        config: SHIKI_CONFIG,
        getCurrentTheme: getCurrentTheme
    };

})();
"""
end

end # module
