// Shiki Highlighter for Documenter.jl
(function() {
    'use strict';

    const SHIKI_CONFIG = {
        theme: 'github-light',
        darkTheme: 'github-dark',
        languages: ["julia", "javascript", "python", "bash", "json", "yaml", "toml"],
        themes: ["github-light", "github-dark"],
        cdnUrl: 'https://esm.sh'
    };

    let shikiHighlighter = null;
    let isLoading = false;
    let loadingPromise = null;

    console.log('üé® ShikiHighlighter initialized');
    console.log('üìã Config:', SHIKI_CONFIG);

    // Variable to store Transformers
    let shikiTransformers = null;

    // Dynamic import of Shiki
    async function loadShiki() {
        if (shikiHighlighter) return shikiHighlighter;
        if (isLoading) return loadingPromise;

        isLoading = true;

        loadingPromise = (async () => {
            try {
                console.log('üì¶ Loading Shiki highlighter and transformers...');

                // Load Shiki and Transformers in ES Modules format
                const shiki = await import(`${SHIKI_CONFIG.cdnUrl}/shiki@1.22.2`);
                const transformersModule = await import(`${SHIKI_CONFIG.cdnUrl}/@shikijs/transformers@1.22.2`);

                // Save Transformers
                shikiTransformers = transformersModule;

                shikiHighlighter = await shiki.createHighlighter({
                    themes: SHIKI_CONFIG.themes,
                    langs: SHIKI_CONFIG.languages
                });

                console.log('‚úÖ Shiki highlighter and transformers loaded successfully');
                return shikiHighlighter;

            } catch (error) {
                console.error('‚ùå Failed to load Shiki:', error);
                return null;
            } finally {
                isLoading = false;
            }
        })();

        return loadingPromise;
    }

    // Theme detection
    function getCurrentTheme() {
        // Check Documenter theme
        const htmlElement = document.documentElement;

        // Check multiple dark theme classes
        const isDark = htmlElement.classList.contains('theme--dark') ||
                      htmlElement.classList.contains('theme--documenter-dark') ||
                      htmlElement.classList.contains('documenter-dark') ||
                      htmlElement.getAttribute('data-theme') === 'dark' ||
                      htmlElement.getAttribute('data-theme') === 'documenter-dark';

        console.log(`üåì Theme detection: isDark=${isDark}, classes=${htmlElement.className}`);

        // Use dark theme if dark theme is selected
        const selectedTheme = isDark ? SHIKI_CONFIG.darkTheme : SHIKI_CONFIG.theme;

        console.log(`üé® Using theme: ${selectedTheme} (isDark=${isDark})`);

        return selectedTheme;
    }

    // Parse range string: "1,3-4" -> [1, 3, 4]
    function parseHighlightRanges(rangeStr) {
        const ranges = [];
        rangeStr.split(',').forEach(part => {
            part = part.trim();
            if (part.includes('-')) {
                const [start, end] = part.split('-').map(s => parseInt(s.trim()));
                for (let i = start; i <= end; i++) {
                    ranges.push(i);
                }
            } else {
                const num = parseInt(part);
                if (!isNaN(num)) {
                    ranges.push(num);
                }
            }
        });
        return ranges;
    }

    // Add highlight class to specific lines (level-aware)
    function addHighlightToLines(preElement, lineHighlights) {
        const codeElement = preElement.querySelector('code');
        if (!codeElement) return;

        // Get each line <span> generated by Shiki
        const lines = codeElement.querySelectorAll('.line');

        // If lineHighlights is an array (backward compatibility)
        if (Array.isArray(lineHighlights)) {
            lineHighlights.forEach(lineNum => {
                const lineIndex = lineNum - 1;
                if (lines[lineIndex]) {
                    lines[lineIndex].classList.add('highlighted');
                }
            });
        }
        // If lineHighlights is an object (with level, bgcolor support)
        else if (typeof lineHighlights === 'object') {
            Object.entries(lineHighlights).forEach(([lineNum, info]) => {
                const lineIndex = parseInt(lineNum) - 1;
                if (lines[lineIndex]) {
                    // If info is a number (backward compatibility)
                    if (typeof info === 'number') {
                        const colorLevel = ((info - 1) % 4) + 1;
                        lines[lineIndex].classList.add(`highlight-level-${colorLevel}`);
                    }
                    // If info is an object (level + bgcolor)
                    else if (typeof info === 'object') {
                        const level = info.level;
                        const bgcolor = info.bgcolor;

                        if (bgcolor) {
                            // Specify custom background color
                            lines[lineIndex].style.backgroundColor = bgcolor;
                            lines[lineIndex].style.display = 'inline-block';
                            lines[lineIndex].style.width = '100%';
                            lines[lineIndex].style.position = 'relative';
                            console.log(`   üé® Applied custom bgcolor "${bgcolor}" to line ${lineNum}`);
                        } else {
                            // Use default level color
                            const colorLevel = ((level - 1) % 4) + 1;
                            lines[lineIndex].classList.add(`highlight-level-${colorLevel}`);
                        }
                    }
                }
            });
        }
    }

    // Highlight code block
    async function highlightCodeBlock(codeBlock) {
        const pre = codeBlock.parentElement;

        // Save original code (use from data attribute if saved)
        let code = pre.dataset.originalCode || codeBlock.textContent;

        // Save original code and language on first render
        if (!pre.dataset.originalCode) {
            pre.dataset.originalCode = code;
            const langClass = Array.from(codeBlock.classList).find(cls => cls.startsWith('language-'));
            if (langClass) {
                pre.dataset.originalLang = langClass;
            }
        }

        const langClass = Array.from(codeBlock.classList).find(cls => cls.startsWith('language-'));
        let lang = langClass ? langClass.replace('language-', '') : 'text';

        // Skip Shiki processing for languages starting with nohighlight-
        if (lang.startsWith('nohighlight-') || lang === 'nohighlight') {
            console.log(`üö´ Skipping Shiki for nohighlight block`);
            return;
        }

        // Treat julia-repl as julia
        if (lang === 'julia-repl') {
            lang = 'julia';
        }

        // Detect @highlight: format
        let customHighlightLines = {};
        const lines = code.split('\n');
        let filteredLines = [];
        let highlightStack = []; // Nesting level stack
        let lineOffset = 0;

        // Process each line
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            // @highlight: 1,3-4 format
            if (i === 0 && line.match(/^\s*[#\/\/]\s*@highlight:\s*([\d,-]+)/)) {
                const match = line.match(/^\s*[#\/\/]\s*@highlight:\s*([\d,-]+)/);
                const ranges = parseHighlightRanges(match[1]);
                ranges.forEach(lineNum => {
                    customHighlightLines[lineNum] = 1;
                });
                console.log(`üìå Custom highlight detected: lines $${ranges.join(', ')}`);
                lineOffset++;
                continue; // Skip this line
            }

            // Process inline @highlight-end first
            if (line.match(/[#\/\/]\s*@highlight-end\s*$/)) {
                // Apply current highlight level (before processing @highlight-end)
                if (highlightStack.length > 0) {
                    const current = highlightStack[highlightStack.length - 1];
                    customHighlightLines[i - lineOffset + 1] = current;
                    console.log(`   üìç Line $${i - lineOffset + 1} will be highlighted with level $${current.level} (before end)`);
                }
                console.log(`üîö Found @highlight-end at line $${i + 1}`);
                highlightStack.pop();
                // Remove directive and keep line
                const cleanedLine = line.replace(/\s*[#\/\/]\s*@highlight-end\s*$/, '');
                filteredLines.push(cleanedLine);
                continue;
            }

            // Process standalone @highlight-auto-end (at line start) first
            if (line.match(/^\s*[#\/\/]\s*@highlight-auto-end\s*$/)) {
                console.log(`üîö Found @highlight-auto-end (standalone) at line $${i + 1} - will be removed`);
                highlightStack.pop();
                lineOffset++;
                continue; // Skip this line (remove)
            }

            // Inline @highlight-auto-end
            if (line.match(/[#\/\/]\s*@highlight-auto-end\s*$/)) {
                // Apply current highlight level (before processing @highlight-auto-end)
                if (highlightStack.length > 0) {
                    const current = highlightStack[highlightStack.length - 1];
                    customHighlightLines[i - lineOffset + 1] = current;
                    console.log(`   üìç Line $${i - lineOffset + 1} will be highlighted with level $${current.level} (before auto-end)`);
                }
                console.log(`üîö Found @highlight-auto-end at line $${i + 1}`);
                highlightStack.pop();
                // Remove directive and keep line
                const cleanedLine = line.replace(/\s*[#\/\/]\s*@highlight-auto-end\s*$/, '');
                filteredLines.push(cleanedLine);
                continue;
            }

            // @highlight-start[level] format (at line start or end)
            const startMatch = line.match(/^\s*[#\/\/]\s*@highlight-start(?:\[(\d+)\])?|[#\/\/]\s*@highlight-start(?:\[(\d+)\])?\s*$/);
            if (startMatch) {
                const level = startMatch[1] || startMatch[2] || 1;
                const levelNum = typeof level === 'string' ? parseInt(level) : 1;

                // Validate level
                if (levelNum < 1) {
                    console.error(`‚ùå ERROR at line $${i + 1}: @highlight-start level must be >= 1, got $${levelNum}`);
                    filteredLines.push(line);
                    continue;
                }

                // Validate nesting continuity
                const expectedLevel = highlightStack.length + 1;
                if (levelNum !== expectedLevel) {
                    // First level must be 1
                    if (highlightStack.length === 0) {
                        console.error(`‚ùå ERROR at line $${i + 1}: First @highlight-start must be level 1, got $${levelNum}`);
                    } else {
                        console.error(`‚ùå ERROR at line $${i + 1}: @highlight-start[$${levelNum}] skips nesting levels. Expected level $${expectedLevel} (current stack: [$${highlightStack.join(', ')}])`);
                    }
                    // Continue processing even on error, but warn
                }

                console.log(`üî• Found @highlight-start[$${levelNum}] at line $${i + 1}`);
                highlightStack.push({ level: levelNum, bgcolor: null });
                // Skip entire line if @highlight-start is at line start
                if (line.match(/^\s*[#\/\/]\s*@highlight-start/)) {
                    lineOffset++;
                    continue;
                }
                // Remove directive and keep line if @highlight-start is at line end
                const cleanedLine = line.replace(/\s*[#\/\/]\s*@highlight-start(?:\[(\d+)\])?\s*$/, '');
                filteredLines.push(cleanedLine);
                continue;
            }

            // @highlight-auto-start format (auto-nesting, optional bgcolor)
            const autoStartMatch = line.match(/^\s*[#\/\/]\s*@highlight-auto-start(?:,\s*bgcolor=([#\w]+))?|[#\/\/]\s*@highlight-auto-start(?:,\s*bgcolor=([#\w]+))?\s*$/);
            if (autoStartMatch) {
                // Automatically determine level from stack size (level number increases, colors cycle 1-4)
                const autoLevel = highlightStack.length + 1;
                const bgcolor = autoStartMatch[1] || autoStartMatch[2] || null;

                if (bgcolor) {
                    console.log(`üî• Found @highlight-auto-start,bgcolor=$${bgcolor} at line $${i + 1}, auto level: $${autoLevel}`);
                } else {
                    console.log(`üî• Found @highlight-auto-start at line $${i + 1}, auto level: $${autoLevel}`);
                }

                // Save level and background color as object
                highlightStack.push({ level: autoLevel, bgcolor: bgcolor });

                // Skip entire line if at line start
                if (line.match(/^\s*[#\/\/]\s*@highlight-auto-start/)) {
                    lineOffset++;
                    continue;
                }
                // Remove directive and keep line if at line end
                const cleanedLine = line.replace(/\s*[#\/\/]\s*@highlight-auto-start(?:,\s*bgcolor=[#\w]+)?\s*$/, '');
                filteredLines.push(cleanedLine);
                continue;
            }

            // Standalone @highlight-end at line start (remove - not highlighted)
            if (line.match(/^\s*[#\/\/]\s*@highlight-end\s*$/)) {
                console.log(`üîö Found @highlight-end (standalone) at line $${i + 1} - will be removed`);
                highlightStack.pop();
                lineOffset++;
                continue; // Skip this line (remove)
            }

            // Apply current highlight level
            if (highlightStack.length > 0) {
                // Use deepest level (last element)
                const current = highlightStack[highlightStack.length - 1];
                customHighlightLines[i - lineOffset + 1] = current;
                console.log(`   üìç Line $${i - lineOffset + 1} will be highlighted with level $${current.level}`);
            }

            filteredLines.push(line);
        }

        // Use filtered code
        code = filteredLines.join('\n');

        // Debug: log filteredLines content
        if (Object.keys(customHighlightLines).length > 0) {
            console.log('DEBUG: filteredLines (' + filteredLines.length + ' lines):', filteredLines);
            console.log('DEBUG: code after join:', code);
        }

        // Skip Shiki processing for text language (plain text display)
        if (lang === 'text') {
            console.log(`üìù Skipping Shiki for plain text block`);
            return;
        }

        // Skip if language is not supported
        if (!SHIKI_CONFIG.languages.includes(lang)) {
            console.log(`‚ö†Ô∏è  Skipping unsupported language: ${lang}`);
            return;
        }

        try {
            const highlighter = await loadShiki();
            if (!highlighter) {
                console.warn('‚ö†Ô∏è  Highlighter not available, skipping...');
                return;
            }

            const theme = getCurrentTheme();
            console.log(`üé® Highlighting ${lang} code with theme: ${theme}`);

            // Use Transformers to highlight
            const transformers = [];
            if (shikiTransformers) {
                // Highlight by metadata {1,3-4} format
                if (shikiTransformers.transformerMetaHighlight) {
                    transformers.push(shikiTransformers.transformerMetaHighlight());
                }
                // Highlight by comment notation [!code highlight]
                if (shikiTransformers.transformerNotationHighlight) {
                    transformers.push(shikiTransformers.transformerNotationHighlight({
                        matchAlgorithm: 'v3'  // Count from line after comment line
                    }));
                }
                // Transformer for diff display (optional)
                if (shikiTransformers.transformerNotationDiff) {
                    transformers.push(shikiTransformers.transformerNotationDiff({
                        matchAlgorithm: 'v3'
                    }));
                }
            }

            const html = highlighter.codeToHtml(code, {
                lang,
                theme,
                transformers: transformers
            });

            // Create new Shiki element
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            const shikiPre = tempDiv.querySelector('pre');

            if (shikiPre) {
                // Apply if custom highlight lines exist
                if (Object.keys(customHighlightLines).length > 0) {
                    console.log(`‚ú® Applying highlights:`, customHighlightLines);
                    addHighlightToLines(shikiPre, customHighlightLines);
                }

                // Add copy button
                const copyButton = document.createElement('button');
                copyButton.className = 'copy-button';
                copyButton.textContent = 'Copy';
                copyButton.onclick = (e) => {
                    e.preventDefault();
                    navigator.clipboard.writeText(code).then(() => {
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => copyButton.textContent = 'Copy', 2000);
                    }).catch(() => {
                        // Fallback: use textarea
                        const textarea = document.createElement('textarea');
                        textarea.value = code;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => copyButton.textContent = 'Copy', 2000);
                    });
                };
                shikiPre.appendChild(copyButton);

                // Replace original element
                const parentPre = codeBlock.closest('pre');
                if (parentPre) {
                    parentPre.parentNode.replaceChild(shikiPre, parentPre);
                } else {
                    codeBlock.parentNode.replaceChild(shikiPre, codeBlock);
                }
            }

        } catch (error) {
            console.error('‚ùå Error highlighting code:', error);
        }
    }

    // Process all code blocks
    async function highlightAllCodeBlocks() {
        // Skip if already processing
        if (highlightAllCodeBlocks.isRunning) {
            console.log('‚è≥ Highlight already in progress, skipping...');
            return;
        }
        highlightAllCodeBlocks.isRunning = true;

        try {
            // Select all code blocks including those with highlight.js class
            // Process even with hljs class
            const codeBlocks = document.querySelectorAll('pre:not(.shiki) code[class*="language-"], pre:not(.shiki) code.hljs, pre:not(.shiki) code:not([class])');

            if (codeBlocks.length === 0) {
                console.log('üìÑ No unprocessed code blocks found');
                return;
            }

            console.log(`üîç Found ${codeBlocks.length} code blocks to highlight`);

            // Show loading state
            codeBlocks.forEach(block => {
                const pre = block.closest('pre');
                if (pre && !pre.classList.contains('shiki')) {
                    pre.classList.add('shiki-loading');
                }
            });

            // Limit concurrent executions with batch processing
            const BATCH_SIZE = 5;
            const codeBlocksArray = Array.from(codeBlocks);

            for (let i = 0; i < codeBlocksArray.length; i += BATCH_SIZE) {
                const batch = codeBlocksArray.slice(i, i + BATCH_SIZE);
                await Promise.all(batch.map(highlightCodeBlock));
            }

            // Remove loading state
            document.querySelectorAll('.shiki-loading').forEach(el => {
                el.classList.remove('shiki-loading');
            });

            console.log(`üéâ Successfully highlighted ${codeBlocks.length} code blocks with Shiki`);
        } finally {
            highlightAllCodeBlocks.isRunning = false;
        }
    }

    // Monitor theme changes
    function observeThemeChanges() {
        const observer = new MutationObserver(async (mutations) => {
            for (const mutation of mutations) {
                if (mutation.type === 'attributes' &&
                    (mutation.attributeName === 'class' || mutation.attributeName === 'data-theme')) {
                    console.log('üé® Theme changed, re-highlighting...');

                    // Reset Highlighter instance
                    highlighterInstance = null;

                    // Restore existing Shiki blocks to original state
                    const blocks = document.querySelectorAll('pre.shiki');
                    for (const pre of blocks) {
                        const codeElement = pre.querySelector('code');
                        if (codeElement && pre.dataset.originalCode) {
                            // Restore original code
                            codeElement.textContent = pre.dataset.originalCode;
                            // Remove Shiki class to allow reprocessing
                            pre.classList.remove('shiki');
                            // Keep original class
                            const langClass = pre.dataset.originalLang;
                            if (langClass && !codeElement.classList.contains(langClass)) {
                                codeElement.classList.add(langClass);
                            }
                        }
                    }

                    // Wait a bit then re-highlight
                    await new Promise(resolve => setTimeout(resolve, 200));
                    await highlightAllCodeBlocks();
                    break;
                }
            }
        });

        observer.observe(document.documentElement, {
            attributes: true,
            attributeFilter: ['class', 'data-theme']
        });

        // Also monitor prefers-color-scheme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', async () => {
            console.log('üåô System theme changed, re-highlighting...');

            // Reset Highlighter instance
            highlighterInstance = null;

            // Restore existing Shiki blocks to original state
            const blocks = document.querySelectorAll('pre.shiki');
            for (const pre of blocks) {
                const codeElement = pre.querySelector('code');
                if (codeElement && pre.dataset.originalCode) {
                    // Restore original code
                    codeElement.textContent = pre.dataset.originalCode;
                    // Remove Shiki class to allow reprocessing
                    pre.classList.remove('shiki');
                    // Keep original class
                    const langClass = pre.dataset.originalLang;
                    if (langClass && !codeElement.classList.contains(langClass)) {
                        codeElement.classList.add(langClass);
                    }
                }
            }

            // Wait a bit then re-highlight
            await new Promise(resolve => setTimeout(resolve, 200));
            await highlightAllCodeBlocks();
        });
    }

    // Execute when DOM is ready
    function initialize() {
        // Start monitoring theme changes first
        observeThemeChanges();

        // Try highlighting at multiple timings
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                highlightAllCodeBlocks();
            });
        } else {
            // Execute immediately
            highlightAllCodeBlocks();
        }

        // Wait for Documenter initialization to complete
        setTimeout(() => {
            highlightAllCodeBlocks();
        }, 250);

        // Delay further and re-execute (fallback)
        setTimeout(() => {
            highlightAllCodeBlocks();
        }, 1000);
    }

    // Execute initialization
    initialize();

    // Also execute after entire page load
    window.addEventListener('load', () => {
        setTimeout(highlightAllCodeBlocks, 100);
    });

    // Publish globally (for debugging)
    window.ShikiHighlighter = {
        rehighlight: highlightAllCodeBlocks,
        config: SHIKI_CONFIG,
        getCurrentTheme: getCurrentTheme
    };

})();
